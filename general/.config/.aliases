#!/bin/bash
[ -f "$HOME/.config/.aliases_work" ]
# programs
alias tmux="tmux -f ~/.config/tmux/tmux.conf"
alias v="nvim"
alias irssi="irssi --home=~/.config/irssi --config=~/.config/irssi/config"
alias lynx="lynx -cfg=~/.config/lynx/lynx.cfg -lss=~/.config/lynx/lynx.lss"

alias srcz=". ~/.config/zsh/.zshrc"
alias srca=". ~/.config/zsh/.aliases"
alias .s="nvim ~/.dotfiles/scripts/.local/share/scripts/"
alias xin='xinput map-to-output $(xinput | grep -i "pen pen"| cut -d = -f 2 | cut -d [ -f 1) DP-1'
alias r='ranger .'
alias xmr="xmonad --recompile; xmonad --restart"
alias .dxm="cp ~/.config/xmonad/xmonad.hs ~/.dotfiles/xmonad/.config/xmonad/xmonad.hs; cp ~/.config/xmobar/xmobarrc1 ~/.dotfiles/xmonad/.config/xmobar/xmobarrc1; cp ~/.config/xmobar/xmobarrc2 ~/.dotfiles/xmonad/.config/xmobar/xmobarrc2"
alias rex="xrandr --output DP-1 --primary --right-of eDP-1 --auto"
alias \?="noglob ?"
alias \?g="noglob ?g"
alias \?r="noglob ?r"
alias \?s="noglob ?s"

# scripts
alias sz="tmux-sessionizer"

# builtin
alias c="cd"
alias f="find"

# git
alias gcA="git commit --amend"
alias gcAn="git commit --amend --no-edit"
alias gR="git reset"
alias grs="git remote set-url"
alias grso="git remote set-url origin"
alias grg="git remote get-url origin"

# tmux
alias tms="tmux-sessionizer"

# curl
alias curlh='curl --header "Content-Type: application/json"'

# ansible
alias an="ansible"
alias anp="ansible-playbook"
ashell() {
    # a shell command
    ansible $1 -m shell -a $2
}



alias run_debian="~/.local/share/ansible/run_debian"
alias run_arch="~/.local/share/ansible/run_arch"
alias ssh_phone="ssh -p 8022 u0_a473@axlknight1-everest.nord"
alias toasc="ascii-image-converter"


# functions

clone() {
    local repo="$1" "$USER" ;
    local repo="${repo#https://github.com/}"
    local repo="${repo#git@github.com:}";
    if [[ $repo =~ / ]]; then
        user="${repo%%/*}"
    else
        user="$GITUSER"
        [[ -z "$user" ]] && user="$USER";
    fi;
    local name="${repo##*/}";
    local userd="${REPOS:-$HOME/repos}/github.com/$user";
    local _path="$userd/$name";
    [[ -d "$_path" ]] && cd "$_path" && return;
    mkdir -p "$userd";
    cd "$userd";
    echo gh repo clone "$user/$name" -- --depth 1 --recurse-submodules;
    gh repo clone  "$user/$name" -- --depth 1 --recurse-submodules;
    cd "$name"
}

program() {
    local _file="$1";
    local ext="${_file##*.}";
    local name="${${_file%.*}##*/}";
    local name="${name%.tar}";
    local programs="${PROGRAMS:-$HOME/programs/}"
    local _path="$programs/$name";
    [[ -d "$_path" ]] && cd "$_path" && return;
    mv "$_file" "$programs";
    cd "$programs"
    declare -A methods=([gz]="tar xfv $_file");
    eval "${methods[$ext]}";
    local named;
    named=$(find "$programs" -maxdepth 1 -iname "*${name%%-*}*" -type d);
    echo "$named"
    [[ -d "$named" ]] \
        && cd "$named" \
        && mv "../$_file" "/tmp/" \
        && return;
    mv "$_file" "/tmp/"
    local RED='\033[0;31m'
    echo "${RED}couldn't find folder extracted from file"
}

# vpn
nord() {
    sudo nordvpn set meshnet on
    sudo nordvpn connect japan
}

# dotfiles
dgp() {
    # argument is the path
    clear
    current_folder="$(pwd)"
    cd "$1" || return
    echo "\e[35mIN $(basename $1 | tr a-z A-Z)"
    changes=$(git status -s)
    if [ -z "$(tr -d '\n' <<< "$changes")" ]; then 
        printf "\e[31mno changes\n"
        return
    fi
    git status -s
    printf "\nmessage: \n"
    read -r message
    git add -u
    # if there are untracked files, choose to add them
    if [[ -n $(git ls-files --other --directory --exclude-standard | sed q1) ]]; then
        echo -e "\nadd untracked files? [y/N]"
        read -r untracked
        if [[ "$untracked" == "y" || "$untracked" == "Y" ]]; then
            git add -A
        fi
    fi
    git commit -m "$message"
    git push origin HEAD
    cd "$current_folder" || return
}

dgpa() {
    dgp "$WIKI"
    dgp "$DOTFILES"
}

dgpd() {
    dgp "$DOTFILES"
}

dgpw() {
    dgp "$WIKI"
}
